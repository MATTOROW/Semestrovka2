<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${project.name} + ' | Task Tracker'">Project | Task Tracker</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link th:href="@{/css/navbar.css}" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.8.2/dist/alpine.min.js" defer></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        :root {
            --navbar-height: 4.5rem;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            padding-top: var(--navbar-height);
        }

        .notification {
            position: fixed;
            top: 1rem;
            right: 1rem;
            max-width: 24rem;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            align-items: center;
            transform: translateX(150%);
            transition: transform 0.3s ease-in-out;
            z-index: 50;
        }
        .notification.show {
            transform: translateX(0);
        }
        .notification.success {
            background-color: #10b981;
            color: white;
        }
        .notification.error {
            background-color: #ef4444;
            color: white;
        }
        .notification-icon {
            margin-right: 0.75rem;
            font-size: 1.25rem;
        }

        .modal-content {
            background-color: #1e293b;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #1e293b !important;
            opacity: 1 !important;
        }

        .project-header {
            backdrop-filter: blur(16px);
            background: rgba(15, 23, 42, 0.7);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .category-column {
            min-width: 400px;
            max-width: 400px;
            max-height: calc(100vh - var(--navbar-height) - 180px);
            height: 100%;
            background: rgba(30, 41, 59, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            flex-direction: column;
        }

        .tasks-container {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .category-footer {
            padding: 0.75rem;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        .task-card {
            background: rgba(51, 65, 85, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.2s ease;
        }
        .task-card:hover {
            transform: translateY(-2px);
            border-color: rgba(148, 163, 184, 0.3);
        }

        .task-card {
            transition: transform 0.2s ease;
        }
        .task-card.dragging {
            transform: rotate(3deg);
        }

        .gradient-text {
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            background-image: linear-gradient(135deg, #818cf8 0%, #c471f5 100%);
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .category-header {
            border-top: 3px solid;
        }

        /* Стиль для скроллбара задач */
        .tasks-container {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
            scrollbar-width: thin;
            scrollbar-color: rgba(148, 163, 184, 0.3) transparent;
            padding-bottom: 10px;
        }

        .tasks-container::-webkit-scrollbar {
            width: 6px;
        }

        .tasks-container::-webkit-scrollbar-thumb {
            background-color: rgba(148, 163, 184, 0.3);
            border-radius: 3px;
        }

        .input-field {
            background: rgba(30, 41, 59, 0.4);
            border: 1px solid rgba(148, 163, 184, 0.2);
            transition: all 0.2s ease;
        }
        .input-field:hover {
            border-color: rgba(148, 163, 184, 0.4);
        }
        .input-field:focus {
            outline: none;
            border-color: #818cf8;
            box-shadow: 0 0 0 1px #818cf8;
        }

        .loading-spinner {
            display: none;
            width: 24px;
            height: 24px;
            margin: 10px auto;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: #818cf8;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .subtask-group {
            background: rgba(51, 65, 85, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .subtask-group-header {
            padding: 0.75rem 1rem;
            background: rgba(71, 85, 105, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .subtask-group-content {
            padding: 0.75rem;
        }

        .subtask-item {
            background: rgba(71, 85, 105, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            transition: all 0.2s ease;
        }

        .subtask-item:hover {
            background: rgba(71, 85, 105, 0.4);
        }

        .subtask-item.dragging {
            opacity: 0.5;
            border: 1px dashed #818cf8;
        }

        .subtask-group.dragging {
            border: 1px dashed #818cf8;
        }

        .drag-handle {
            cursor: move;
            margin-right: 0.5rem;
            color: #94a3b8;
        }

        .subtask-actions {
            margin-left: auto;
            display: flex;
            gap: 0.5rem;
        }

        .subtask-checkbox {
            margin-right: 0.75rem;
        }
    </style>
</head>
<body class="min-h-screen">

<div th:replace="fragments/navbar :: navbar" class="fixed top-0 left-0 right-0 z-50 px-6 py-3 flex items-center justify-between h-[var(--navbar-height)]"></div>

<!-- Шапка проекта -->
<header class="project-header sticky top-[var(--navbar-height)] z-40 py-4 px-6">
    <div class="container mx-auto flex justify-between items-center">
        <div>
            <h1 class="text-2xl font-bold gradient-text" th:text="${project.name}">Project Name</h1>
            <p class="text-slate-400 text-sm mt-1" th:text="${project.description} ?: 'No description'"></p>
        </div>
        <div class="flex space-x-4">
            <button onclick="window.location.href=window.location.pathname + '/edit'" class="px-4 py-2 text-slate-400 hover:text-white transition-colors">
                Settings
            </button>
            <button onclick="openCreateCategoryModal()"
                    class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg transition-colors">
                + Add Category
            </button>
        </div>
    </div>
</header>

<!-- Основное содержимое - горизонтальный скролл категорий -->
<main class="container mx-auto px-4 py-6 overflow-x-auto scrollbar-hide">

    <div id="notification" class="notification hidden">
        <span id="notification-icon" class="notification-icon">✓</span>
        <div>
            <div id="notification-title" class="font-medium"></div>
            <div id="notification-message" class="text-sm opacity-90"></div>
            <ul id="notification-errors" class="mt-1 text-xs list-disc list-inside"></ul>
        </div>
    </div>

    <div id="categoriesContainer" class="flex space-x-4 pb-4">
        <!-- Категории будут загружаться здесь -->
    </div>
</main>

<!-- Модальные окна -->
<div id="createCategoryModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-slate-800 rounded-xl p-6 w-full max-w-md modal-content">
        <h2 class="text-xl font-bold mb-4">Create New Category</h2>
        <form id="createCategoryForm">
            <div class="mb-4">
                <label class="block text-sm mb-2">Category Name</label>
                <input type="text" name="name" required minlength="2" maxlength="30"
                       class="input-field w-full rounded-lg px-3 py-2">
            </div>
            <div class="mb-4">
                <label class="block text-sm mb-2">Color</label>
                <div class="flex items-center">
                    <input type="color" name="color" value="#3b82f6"
                           class="w-10 h-10 rounded cursor-pointer mr-3">
                    <input type="text" name="colorText" value="#3b82f6" pattern="^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$"
                           class="input-field flex-1 rounded-lg px-3 py-2 font-mono text-sm">
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" onclick="closeCreateCategoryModal()"
                        class="px-4 py-2 text-slate-400 hover:text-white">
                    Cancel
                </button>
                <button type="submit" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg">
                    Create
                </button>
            </div>
        </form>
    </div>
</div>

<div id="deleteCategoryModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-slate-800 rounded-xl p-6 w-full max-w-md modal-content">
        <h2 class="text-xl font-bold mb-4">Delete Category</h2>
        <form id="deleteCategoryForm">
            <input type="hidden" id="categoryToDeleteId">
            <div class="mb-4">
                <label class="block text-sm mb-2">Move tasks to:</label>
                <select name="newCategoryId" required class="input-field w-full rounded-lg px-3 py-2">
                    <!-- Опции будут заполнены динамически -->
                </select>
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" onclick="closeDeleteCategoryModal()"
                        class="px-4 py-2 text-slate-400 hover:text-white">
                    Cancel
                </button>
                <button type="submit" class="px-4 py-2 bg-rose-600 hover:bg-rose-700 rounded-lg">
                    Delete
                </button>
            </div>
        </form>
    </div>
</div>

<div id="editCategoryModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-slate-800 rounded-xl p-6 w-full max-w-md modal-content">
        <h2 class="text-xl font-bold mb-4">Edit Category</h2>
        <form id="editCategoryForm">
            <input type="hidden" id="editingCategoryId">
            <div class="mb-4">
                <label class="block text-sm mb-2">Category Name</label>
                <input type="text" id="editCategoryName" name="name" required minlength="2" maxlength="30"
                       class="input-field w-full rounded-lg px-3 py-2">
            </div>
            <div class="mb-4">
                <label class="block text-sm mb-2">Color</label>
                <div class="flex items-center">
                    <input type="color" id="editCategoryColor" name="color" value="#3b82f6"
                           class="w-10 h-10 rounded cursor-pointer mr-3">
                    <input type="text" id="editCategoryColorText" name="colorText" value="#3b82f6"
                           pattern="^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$"
                           class="input-field flex-1 rounded-lg px-3 py-2 font-mono text-sm">
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" onclick="closeEditCategoryModal()"
                        class="px-4 py-2 text-slate-400 hover:text-white">
                    Cancel
                </button>
                <button type="submit" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg">
                    Save Changes
                </button>
            </div>
        </form>
    </div>
</div>

<div id="createTaskModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-slate-800 rounded-xl p-6 w-full max-w-md modal-content">
        <h2 class="text-xl font-bold mb-4">Create New Task</h2>
        <form id="createTaskForm">
            <input type="hidden" id="taskCategoryId">
            <div class="mb-4">
                <label class="block text-sm mb-2">Task Name*</label>
                <input type="text" name="name" required maxlength="70"
                       class="input-field w-full rounded-lg px-3 py-2">
            </div>
            <div class="mb-4">
                <label class="block text-sm mb-2">Description</label>
                <textarea name="description" rows="3" maxlength="1000"
                          class="input-field w-full rounded-lg px-3 py-2"></textarea>
            </div>
            <div class="mb-4">
                <label class="block text-sm mb-2">Deadline</label>
                <input type="datetime-local" name="deadline"
                       class="input-field w-full rounded-lg px-3 py-2">
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" onclick="closeCreateTaskModal()"
                        class="px-4 py-2 text-slate-400 hover:text-white">
                    Cancel
                </button>
                <button type="submit" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg">
                    Create Task
                </button>
            </div>
        </form>
    </div>
</div>

<div id="taskModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 overflow-y-auto py-10">
    <div class="bg-slate-800 rounded-xl p-6 w-full max-w-4xl max-h-90vh flex flex-col modal-content">
        <div class="flex justify-between items-center mb-6 pb-4 border-b border-slate-700">
            <h2 id="taskModalTitle" class="text-2xl font-bold">Task Details</h2>
            <div class="flex space-x-3">
                <button id="deleteTaskBtn" class="px-4 py-2 bg-rose-600 hover:bg-rose-700 rounded-lg transition-colors">
                    Delete Task
                </button>
                <button onclick="closeTaskModal()" class="px-4 py-2 text-slate-400 hover:text-white">
                    Close
                </button>
            </div>
        </div>

        <div class="flex-1 overflow-y-auto pr-2">
            <div class="mb-8">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div>
                        <label class="block text-sm text-slate-300 mb-1.5">Task Name</label>
                        <input type="text" id="taskName" class="input-field w-full rounded-lg px-3 py-2 text-slate-200">
                    </div>
                    <div>
                        <label class="block text-sm text-slate-300 mb-1.5">Deadline</label>
                        <input type="datetime-local" id="taskDeadline" class="input-field w-full rounded-lg px-3 py-2 text-slate-200">
                    </div>
                </div>
                <div class="mb-4">
                    <label class="block text-sm text-slate-300 mb-1.5">Description</label>
                    <textarea id="taskDescription" rows="3" class="input-field w-full rounded-lg px-3 py-2 text-slate-200"></textarea>
                </div>
            </div>

            <div>
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold">Subtasks Groups</h3>
                    <button onclick="openCreateSubtaskGroupModal()" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm">
                        + Add Group
                    </button>
                </div>

                <div id="subtaskGroupsContainer" class="space-y-6">
                    <!-- Группы будут загружаться здесь -->
                </div>
            </div>
        </div>
    </div>
</div>

<div id="createSubtaskGroupModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-slate-800 rounded-xl p-6 w-full max-w-md modal-content">
        <h2 class="text-xl font-bold mb-4">Create Subtask Group</h2>
        <form id="createSubtaskGroupForm">
            <div class="mb-4">
                <label class="block text-sm mb-2">Group Name</label>
                <input type="text" name="name" required maxlength="150"
                       class="input-field w-full rounded-lg px-3 py-2">
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" onclick="closeCreateSubtaskGroupModal()"
                        class="px-4 py-2 text-slate-400 hover:text-white">
                    Cancel
                </button>
                <button type="submit" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg">
                    Create
                </button>
            </div>
        </form>
    </div>
</div>

<div id="createSubtaskModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-slate-800 rounded-xl p-6 w-full max-w-md modal-content">
        <h2 class="text-xl font-bold mb-4">Create Subtask</h2>
        <form id="createSubtaskForm">
            <input type="hidden" id="subtaskGroupId">
            <div class="mb-4">
                <label class="block text-sm mb-2">Subtask Name</label>
                <input type="text" name="name" required maxlength="150"
                       class="input-field w-full rounded-lg px-3 py-2">
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" onclick="closeCreateSubtaskModal()"
                        class="px-4 py-2 text-slate-400 hover:text-white">
                    Cancel
                </button>
                <button type="submit" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg">
                    Create
                </button>
            </div>
        </form>
    </div>
</div>

<script>
    // Глобальные переменные
    const projectId = '[[${project.id}]]';
    const CACHE_TTL = 300000; // 5 минут
    let categories = [];
    const TASKS_PER_PAGE = 20;
    let tasksLoading = {};
    let hasMoreTasks = {};
    let tasksPage = {};
    let currentTask = null;
    let currentCategoryId = null;
    let subtaskGroups = [];
    let tasksByCategory = {};  // key: categoryId, value: массив задач


    // Инициализация при загрузке страницы
    document.addEventListener('DOMContentLoaded', () => {
        // Пытаемся загрузить данные из кэша
        const cachedData = loadFromCache('projectData');
        if (cachedData && cachedData.categories) {
            categories = cachedData.categories;
            tasksByCategory = cachedData.tasksByCategory || {};
            renderCategories();

            // Обновляем данные с сервера в фоне
            setTimeout(loadCategories, 500);
        } else {
            loadCategories();
        }

        setupModalEventListeners();
        setupColorPicker();
    });

    function saveToCache(key, data) {
        const record = {
            data: data,
            timestamp: Date.now()
        };
        localStorage.setItem(key, JSON.stringify(record));
    }

    function loadFromCache(key) {
        const record = localStorage.getItem(key);
        if (!record) return null;

        const { data, timestamp } = JSON.parse(record);
        if (Date.now() - timestamp > CACHE_TTL) return null;

        return data;
    }

    // Настройка обработчиков событий для модальных окон
    function setupModalEventListeners() {
        // Обработчики для модального окна создания категории
        document.getElementById('createCategoryForm').addEventListener('submit', handleCreateCategory);

        // Обработчики для модального окна редактирования категории
        document.getElementById('editCategoryForm').addEventListener('submit', handleEditCategory);

        // Обработчики для модального окна удаления категории
        document.getElementById('deleteCategoryForm').addEventListener('submit', handleDeleteCategory);

        // Обработчики для модального окна создания задачи
        document.getElementById('createTaskForm').addEventListener('submit', handleCreateTask);

        // Обработчики для модального окна создания группы подзадач
        document.getElementById('createSubtaskGroupForm').addEventListener('submit', handleCreateSubtaskGroup);

        // Обработчики для модального окна создания подзадачи
        document.getElementById('createSubtaskForm').addEventListener('submit', handleCreateSubtask);

        // Обработчик для кнопки удаления задачи
        document.getElementById('deleteTaskBtn').addEventListener('click', handleDeleteTask);
    }

    // Настройка цветового пикера
    function setupColorPicker() {
        const colorPicker = document.querySelector('input[type="color"]');
        const colorText = document.querySelector('input[name="colorText"]');

        colorPicker.addEventListener('input', (e) => {
            colorText.value = e.target.value;
        });

        colorText.addEventListener('input', (e) => {
            if (/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(e.target.value)) {
                colorPicker.value = e.target.value;
            }
        });
    }

    // Загрузка категорий
    async function loadCategories() {
        try {
            const response = await fetch(`/api/v1/projects/${projectId}/categories`, {
                headers: { 'Cache-Control': 'no-cache' }
            });

            if (response.ok) {
                categories = await response.json();
                categories.forEach(cat => {
                    tasksLoading[cat.id] = false;
                    hasMoreTasks[cat.id] = true;
                    tasksPage[cat.id] = 0;

                    // Если задачи для этой категории уже есть в кэше, не загружаем их снова
                    if (!tasksByCategory[cat.id]) {
                        loadTasksForCategory(cat.id);
                    }
                });

                renderCategories();

                // Сохраняем в кэш
                saveToCache('projectData', {
                    categories: categories,
                    tasksByCategory: tasksByCategory
                });
            }
        } catch (error) {
            console.error('Failed to load categories:', error);
        }
    }

    // Рендер категорий
    function renderCategories() {
        const container = document.getElementById('categoriesContainer');
        container.innerHTML = '';

        categories.forEach(category => {
            const categoryCol = document.createElement('div');
            categoryCol.className = 'category-column rounded-lg flex-shrink-0';
            categoryCol.innerHTML = `
                <div class="category-header p-4" style="border-color: ${category.color}">
                    <div class="flex justify-between items-center">
                        <h3 class="font-semibold" style="color: ${category.color}">${category.name}</h3>
                        <div class="relative" x-data="{ open: false }">
                            <button @click="open = !open" class="text-slate-400 hover:text-white p-1 rounded hover:bg-slate-700 transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path d="M6 10a2 2 0 11-4 0 2 2 0 014 0zM12 10a2 2 0 11-4 0 2 2 0 014 0zM16 12a2 2 0 100-4 2 2 0 000 4z" />
                                </svg>
                            </button>

                            <div x-show="open" @click.away="open = false" class="absolute left-full mt-2 w-40 rounded-md shadow-lg z-20 border border-slate-700" style="background-color: #1e293b;">
                                <div class="py-1">
                                    <button @click="openEditCategoryModal('${category.id}'); open = false" class="block w-full text-left px-4 py-2 text-sm hover:bg-slate-700">
                                        Изменить
                                    </button>
                                    <button @click="openDeleteCategoryModal('${category.id}'); open = false" class="block w-full text-left px-4 py-2 text-sm text-rose-400 hover:bg-slate-700">
                                        Удалить
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="tasks-${category.id}" class="tasks-container">
                    <div class="loading-spinner" id="spinner-${category.id}"></div>
                </div>
                <div class="category-footer">
                    <button onclick="openCreateTaskModal('${category.id}')" class="w-full py-2 text-slate-400 hover:text-white text-sm">
                        + Add Task
                    </button>
                </div>
            `;
            container.appendChild(categoryCol);
            loadTasksForCategory(category.id);
        });
    }

    // Загрузка задач для категории
    async function loadTasksForCategory(categoryId, loadMore = false) {
        if (tasksLoading[categoryId] || !hasMoreTasks[categoryId]) return;

        tasksLoading[categoryId] = true;
        const spinner = document.getElementById(`spinner-${categoryId}`);
        if (spinner) spinner.style.display = 'block';

        try {
            const page = loadMore ? tasksPage[categoryId] : 0;
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${categoryId}/tasks/search?page=${page}&size=${TASKS_PER_PAGE}`,
                { headers: { 'Cache-Control': 'no-cache' } }
            );

            if (response.ok) {
                const data = await response.json();
                hasMoreTasks[categoryId] = !data.last;
                tasksPage[categoryId] = page + 1;

                if (loadMore && tasksByCategory[categoryId]) {
                    tasksByCategory[categoryId] = [...tasksByCategory[categoryId], ...data.content];
                } else {
                    tasksByCategory[categoryId] = data.content;
                }

                renderTasks(categoryId, data.content, loadMore);

                // Обновляем кэш
                const cachedData = loadFromCache('projectData') || {};
                cachedData.tasksByCategory = tasksByCategory;
                saveToCache('projectData', cachedData);
            }
        } catch (error) {
            console.error('Failed to load tasks:', error);
        } finally {
            tasksLoading[categoryId] = false;
            const spinner = document.getElementById(`spinner-${categoryId}`);
            if (spinner) spinner.style.display = 'none';
        }
    }

    // Рендер задач
    function renderTasks(categoryId, tasks, append = false) {
        const container = document.getElementById(`tasks-${categoryId}`);
        if (!container) return;

        if (!append) {
            container.innerHTML = '';
        }

        tasks.forEach(task => {
            const taskElement = document.createElement('div');
            taskElement.className = 'task-card rounded-lg p-3 cursor-pointer mb-2';
            taskElement.dataset.taskId = task.id;
            taskElement.onclick = () => openTaskModal(task.id, categoryId);
            taskElement.innerHTML = `
                <h4 class="font-medium mb-1 task-name">${task.name}</h4>
                <div class="flex justify-between items-center text-xs text-slate-400">
                    <span class="task-status">${task.status}</span>
                    <span class="task-deadline">${task.deadline ? new Date(task.deadline).toLocaleDateString() : 'No deadline'}</span>
                </div>
            `;
            container.appendChild(taskElement);
        });

        setupDragAndDrop();
    }

    // Настройка drag-and-drop для задач
    function setupDragAndDrop() {
        const tasksContainers = document.querySelectorAll('[id^="tasks-"]');

        tasksContainers.forEach(container => {
            // Удаляем старые обработчики, если они есть
            container.removeEventListener('scroll', handleTaskScroll);
            container.removeEventListener('dragover', handleTaskDragOver);
            container.removeEventListener('drop', handleTaskDrop);

            // Добавляем новые обработчики
            container.addEventListener('scroll', handleTaskScroll);
            container.addEventListener('dragover', handleTaskDragOver);
            container.addEventListener('drop', handleTaskDrop);
        });

        // Обработчики для задач
        document.querySelectorAll('.task-card').forEach(task => {
            task.setAttribute('draggable', 'true');

            // Удаляем старые обработчики
            task.removeEventListener('dragstart', handleTaskDragStart);
            task.removeEventListener('dragend', handleTaskDragEnd);

            // Добавляем новые обработчики
            task.addEventListener('dragstart', handleTaskDragStart);
            task.addEventListener('dragend', handleTaskDragEnd);
        });
    }

    // Обработчики событий для drag-and-drop задач
    function handleTaskScroll(e) {
        const container = e.target;
        const categoryId = container.id.replace('tasks-', '');

        if (container.scrollTop + container.clientHeight >= container.scrollHeight - 50 &&
            !tasksLoading[categoryId] && hasMoreTasks[categoryId]) {
            loadTasksForCategory(categoryId, true);
        }
    }

    function handleTaskDragOver(e) {
        e.preventDefault();
        const afterElement = getDragAfterElementReverse(e.currentTarget, e.clientY);
        const taskBeingDragged = document.querySelector('.task-card.dragging');

        if (!taskBeingDragged) return;

        if (afterElement) {
            e.currentTarget.insertBefore(taskBeingDragged, afterElement);
        } else {
            e.currentTarget.appendChild(taskBeingDragged);
        }
    }

    function handleTaskDrop(e) {
        e.preventDefault();
        e.stopPropagation();

        const taskId = e.dataTransfer.getData('text/plain');
        const sourceCategoryId = e.dataTransfer.getData('source-category');
        const targetCategoryId = e.currentTarget.id.replace('tasks-', '');

        const tasks = Array.from(e.currentTarget.querySelectorAll('.task-card:not(.dragging)'));
        const afterElement = getDragAfterElementReverse(e.currentTarget, e.clientY);
        let newPosition = tasks.length;

        if (afterElement) {
            const afterIndex = tasks.findIndex(task => task === afterElement);
            newPosition = afterIndex >= 0 ? afterIndex : tasks.length;
        }

        moveTask(taskId, sourceCategoryId, targetCategoryId, newPosition)
            .catch(error => {
                console.error('Move error:', error);
                loadTasksForCategory(sourceCategoryId);
                if (sourceCategoryId !== targetCategoryId) {
                    loadTasksForCategory(targetCategoryId);
                }
            });

        document.querySelectorAll('.task-card').forEach(t => t.classList.remove('dragging'));
    }

    function handleTaskDragStart(e) {
        e.dataTransfer.setData('text/plain', e.target.dataset.taskId);
        e.dataTransfer.setData('source-category', e.target.closest('[id^="tasks-"]').id.replace('tasks-', ''));
        e.dataTransfer.effectAllowed = 'move';
        e.target.classList.add('dragging');
    }

    function handleTaskDragEnd(e) {
        document.querySelectorAll('.task-card').forEach(t => t.classList.remove('dragging'));
    }

    // Функция для определения позиции при перетаскивании
    function getDragAfterElementReverse(container, y) {
        const draggableElements = [...container.querySelectorAll('.task-card:not(.dragging)')];
        const reversedElements = [...draggableElements].reverse();

        return reversedElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;

            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Перемещение задачи
    async function moveTask(taskId, sourceCategoryId, targetCategoryId, newPosition) {
        const tasks = Array.from(document.querySelectorAll(`#tasks-${targetCategoryId} .task-card:not(.dragging)`));
        const backendPosition = tasks.length - newPosition;

        const response = await fetch(
            `/api/v1/projects/${projectId}/categories/${sourceCategoryId}/tasks/${taskId}/move`,
            {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    categoryId: targetCategoryId,
                    position: backendPosition
                })
            }
        );

        if (!response.ok) {
            throw new Error('Failed to move task');
        }

        loadTasksForCategory(sourceCategoryId);
        if (sourceCategoryId !== targetCategoryId) {
            loadTasksForCategory(targetCategoryId);
        }
    }

    // Управление модальными окнами категорий
    function openCreateCategoryModal() {
        document.getElementById('createCategoryModal').classList.remove('hidden');
    }

    function closeCreateCategoryModal() {
        document.getElementById('createCategoryModal').classList.add('hidden');
        document.getElementById('createCategoryForm').reset();
    }

    function openEditCategoryModal(categoryId) {
        const category = categories.find(c => c.id === categoryId);
        if (category) {
            document.getElementById('editingCategoryId').value = categoryId;
            document.getElementById('editCategoryName').value = category.name;
            document.getElementById('editCategoryColor').value = category.color;
            document.getElementById('editCategoryColorText').value = category.color;
            document.getElementById('editCategoryModal').classList.remove('hidden');
        }
    }

    function closeEditCategoryModal() {
        document.getElementById('editCategoryModal').classList.add('hidden');
    }

    function openDeleteCategoryModal(categoryId) {
        const modal = document.getElementById('deleteCategoryModal');
        document.getElementById('categoryToDeleteId').value = categoryId;

        const select = modal.querySelector('select');
        select.innerHTML = '';
        categories
            .filter(c => c.id !== categoryId)
            .forEach(c => {
                const option = document.createElement('option');
                option.value = c.id;
                option.textContent = c.name;
                select.appendChild(option);
            });

        modal.classList.remove('hidden');
    }

    function closeDeleteCategoryModal() {
        document.getElementById('deleteCategoryModal').classList.add('hidden');
    }

    // Управление модальными окнами задач
    function openCreateTaskModal(categoryId) {
        document.getElementById('taskCategoryId').value = categoryId;
        document.getElementById('createTaskModal').classList.remove('hidden');
    }

    function closeCreateTaskModal() {
        document.getElementById('createTaskModal').classList.add('hidden');
        document.getElementById('createTaskForm').reset();
    }

    async function openTaskModal(taskId, categoryId) {
        // Пытаемся найти задачу в локальном кэше
        const cachedTask = tasksByCategory[categoryId]?.find(t => t.id === taskId);

        if (cachedTask) {
            currentTask = cachedTask;
            currentCategoryId = categoryId;
            populateTaskModal(cachedTask);

            // Загружаем подзадачи в фоне
            loadSubtaskGroups(taskId).catch(console.error);

            document.getElementById('taskModal').classList.remove('hidden');
            return;
        }

        // Если задачи нет в кэше, загружаем с сервера
        try {
            const response = await fetch(`/api/v1/projects/${projectId}/categories/${categoryId}/tasks/${taskId}`);
            if (response.ok) {
                currentTask = await response.json();
                currentCategoryId = categoryId;

                // Обновляем кэш
                const taskIndex = tasksByCategory[categoryId]?.findIndex(t => t.id === taskId);
                if (taskIndex >= 0) {
                    tasksByCategory[categoryId][taskIndex] = currentTask;
                }

                populateTaskModal(currentTask);
                await loadSubtaskGroups(taskId);
                document.getElementById('taskModal').classList.remove('hidden');
            }
        } catch (error) {
            console.error('Failed to load task:', error);
        }
    }

    function populateTaskModal(task) {
        document.getElementById('taskName').value = task.name;
        document.getElementById('taskDescription').value = task.description || '';

        if (task.deadline) {
            const deadlineDate = new Date(task.deadline);
            document.getElementById('taskDeadline').value = formatLocalDateTime(deadlineDate);
        } else {
            document.getElementById('taskDeadline').value = '';
        }

        // Настраиваем автосохранение с дебаунсом
        ['taskName', 'taskDescription', 'taskDeadline'].forEach(id => {
            const element = document.getElementById(id);
            element.onchange = debounce(saveTaskChanges, 500);
        });
    }

    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this, args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), wait);
        };
    }

    function closeTaskModal() {
        document.getElementById('taskModal').classList.add('hidden');
        currentTask = null;
        currentCategoryId = null;
        subtaskGroups = [];
    }

    // Сохранение изменений задачи
    async function saveTaskChanges() {
        if (!currentTask || !currentCategoryId) return;

        const updatedTask = {
            name: document.getElementById('taskName').value,
            description: document.getElementById('taskDescription').value,
            deadline: document.getElementById('taskDeadline').value
                ? new Date(document.getElementById('taskDeadline').value)
                : null
        };

        try {
            // Оптимистичное обновление UI
            const taskElement = document.querySelector(`[data-task-id="${currentTask.id}"]`);
            if (taskElement) {
                const taskName = taskElement.querySelector(".task-name");
                const taskDeadline = taskElement.querySelector(".task-deadline");

                if (taskName) taskName.textContent = updatedTask.name;
                if (taskDeadline) {
                    taskDeadline.textContent = updatedTask.deadline
                        ? new Date(updatedTask.deadline).toLocaleDateString()
                        : 'No deadline';
                }
            }

            // Обновляем локальные данные
            Object.assign(currentTask, updatedTask);
            const taskIndex = tasksByCategory[currentCategoryId]?.findIndex(t => t.id === currentTask.id);
            if (taskIndex >= 0) {
                tasksByCategory[currentCategoryId][taskIndex] = currentTask;
            }

            // Сохраняем в кэш
            const cachedData = loadFromCache('projectData') || {};
            cachedData.tasksByCategory = tasksByCategory;
            saveToCache('projectData', cachedData);

            // Отправляем на сервер
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}`,
                {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updatedTask)
                }
            );

            if (!response.ok) {
                throw new Error('Failed to update task');
            }
        } catch (error) {
            console.error('Failed to save task changes:', error);
        }
    }

    // Работа с подзадачами
    async function loadSubtaskGroups(taskId) {
        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${taskId}/groups`,
                { headers: { 'Cache-Control': 'no-cache' } }
            );

            if (response.ok) {
                subtaskGroups = await response.json();

                renderSubtaskGroups();
                setupTaskModalDragAndDrop();
            }
        } catch (error) {
            console.error('Failed to load subtask groups:', error);
        }
    }

    async function loadSubtasksForGroup(groupId) {
        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/${groupId}/subtask`,
                { headers: { 'Cache-Control': 'no-cache' } }
            );

            if (response.ok) {
                return await response.json();
            }
            return [];
        } catch (error) {
            console.error('Failed to load subtasks:', error);
            return [];
        }
    }

    function renderSubtaskGroups() {
        const container = document.getElementById('subtaskGroupsContainer');
        container.innerHTML = '';

        subtaskGroups.forEach(group => {
            const groupElement = document.createElement('div');
            groupElement.className = 'subtask-group';
            groupElement.dataset.groupId = group.id;

            groupElement.innerHTML = `
            <div class="subtask-group-header flex justify-between items-center">
                <div class="flex items-center space-x-2">
                    <span class="drag-handle">☰</span>
                    <input type="checkbox"
                           class="group-checkbox"
                           ${group.completed ? 'checked' : ''}
                           onchange="toggleGroupStatus('${group.id}', this.checked)">
                    <h4 class="font-medium">${group.name}</h4>
                </div>
                <div class="flex space-x-2">
                    <button onclick="openCreateSubtaskModal('${group.id}')"
                            class="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded">
                        + Add Subtask
                    </button>
                    <button onclick="deleteSubtaskGroup('${group.id}')"
                            class="text-xs px-2 py-1 bg-rose-600 hover:bg-rose-700 rounded">
                        Delete
                    </button>
                </div>
            </div>
            <div class="subtask-group-content" id="subtasks-${group.id}">
                <!-- Подзадачи будут здесь -->
            </div>
        `;

            container.appendChild(groupElement);
            renderSubtasks(group.id, group.subtasks || null);
        });
    }

    async function renderSubtasks(groupId, subtasks) {
        const container = document.getElementById(`subtasks-${groupId}`);
        if (!container) return;

        container.innerHTML = '';

        console.log(subtasks)

        if (!subtasks) {
            subtasks = await loadSubtasksForGroup(groupId);
        }

        subtasks.forEach(subtask => {
            const subtaskElement = document.createElement('div');
            subtaskElement.className = 'subtask-item';
            subtaskElement.dataset.subtaskId = subtask.id;

            subtaskElement.innerHTML = `
                <span class="drag-handle">☰</span>
                <input type="checkbox" ${subtask.completed ? 'checked' : ''}
                       class="subtask-checkbox"
                       onchange="toggleSubtaskStatus('${groupId}', '${subtask.id}', this.checked)">
                <span class="${subtask.completed ? 'line-through text-slate-400' : ''}">
                    ${subtask.name}
                </span>
                <div class="subtask-actions">
                    <button onclick="deleteSubtask('${groupId}', '${subtask.id}')"
                            class="text-xs px-2 py-0.5 bg-slate-700 hover:bg-slate-600 rounded">
                        Delete
                    </button>
                </div>
            `;

            container.appendChild(subtaskElement);
        });
    }

    // Настройка drag-and-drop в модальном окне задачи
    function setupTaskModalDragAndDrop() {
        const groupsContainer = document.getElementById('subtaskGroupsContainer');

        // Удаляем старые обработчики
        groupsContainer.removeEventListener('dragover', handleGroupDragOver);
        groupsContainer.removeEventListener('drop', handleGroupDrop);

        // Добавляем новые обработчики
        groupsContainer.addEventListener('dragover', handleGroupDragOver);
        groupsContainer.addEventListener('drop', handleGroupDrop);

        // Обработчики для групп подзадач
        groupsContainer.querySelectorAll('.subtask-group').forEach(group => {
            group.setAttribute('draggable', 'true');

            // Удаляем старые обработчики
            group.removeEventListener('dragstart', handleGroupDragStart);
            group.removeEventListener('dragend', handleGroupDragEnd);

            // Добавляем новые обработчики
            group.addEventListener('dragstart', handleGroupDragStart);
            group.addEventListener('dragend', handleGroupDragEnd);
        });

        // Обработчики для подзадач
        document.querySelectorAll('.subtask-group-content').forEach(container => {
            // Удаляем старые обработчики
            container.removeEventListener('dragover', handleSubtaskDragOver);
            container.removeEventListener('drop', handleSubtaskDrop);

            // Добавляем новые обработчики
            container.addEventListener('dragover', handleSubtaskDragOver);
            container.addEventListener('drop', handleSubtaskDrop);

            container.querySelectorAll('.subtask-item').forEach(subtask => {
                subtask.setAttribute('draggable', 'true');

                // Удаляем старые обработчики
                subtask.removeEventListener('dragstart', handleSubtaskDragStart);
                subtask.removeEventListener('dragend', handleSubtaskDragEnd);

                // Добавляем новые обработчики
                subtask.addEventListener('dragstart', handleSubtaskDragStart);
                subtask.addEventListener('dragend', handleSubtaskDragEnd);
            });
        });
    }

    // Обработчики событий для групп подзадач
    function handleGroupDragStart(e) {
        e.dataTransfer.setData('text/plain', e.target.dataset.groupId);
        e.dataTransfer.effectAllowed = 'move';
        e.target.classList.add('dragging');
        setTimeout(() => e.target.style.opacity = '0.4', 0);
    }

    function handleGroupDragEnd(e) {
        e.target.classList.remove('dragging');
        e.target.style.opacity = '1';
    }

    function handleGroupDragOver(e) {
        e.preventDefault();
        const afterElement = getDragAfterElement(e.currentTarget, e.clientY, '.subtask-group');
        const draggedGroup = document.querySelector('.subtask-group.dragging');

        if (draggedGroup) {
            if (afterElement) {
                e.currentTarget.insertBefore(draggedGroup, afterElement);
            } else {
                e.currentTarget.appendChild(draggedGroup);
            }
        }
    }

    function handleGroupDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        saveGroupsOrder();
    }

    // Обработчики событий для подзадач
    function handleSubtaskDragStart(e) {
        e.dataTransfer.setData('text/plain', e.target.dataset.subtaskId);
        e.dataTransfer.setData('group-id', e.target.closest('.subtask-group').dataset.groupId);
        e.dataTransfer.effectAllowed = 'move';
        e.target.classList.add('dragging');
        setTimeout(() => e.target.style.opacity = '0.4', 0);
    }

    function handleSubtaskDragEnd(e) {
        e.target.classList.remove('dragging');
        e.target.style.opacity = '1';
    }

    function handleSubtaskDragOver(e) {
        e.preventDefault();
        const afterElement = getDragAfterElement(e.currentTarget, e.clientY, '.subtask-item');
        const draggedSubtask = document.querySelector('.subtask-item.dragging');

        if (draggedSubtask && draggedSubtask.parentElement === e.currentTarget) {
            if (afterElement) {
                e.currentTarget.insertBefore(draggedSubtask, afterElement);
            } else {
                e.currentTarget.appendChild(draggedSubtask);
            }
        }
    }

    function handleSubtaskDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        const groupId = e.currentTarget.closest('.subtask-group').dataset.groupId;
        saveSubtasksOrder(groupId);
    }

    // Функция для определения позиции при перетаскивании
    function getDragAfterElement(container, y, selector) {
        const draggableElements = [...container.querySelectorAll(`${selector}:not(.dragging)`)];

        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;

            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Сохранение порядка групп
    async function saveGroupsOrder() {
        const groupOrder = Array.from(document.querySelectorAll('.subtask-group'))
            .map(group => group.dataset.groupId);

        try {
            await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/order`,
                {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ orderedGroupIds: groupOrder })
                }
            );
        } catch (error) {
            showNotification('Error', 'Failed to save groups order', 'error');
        }
    }

    // Сохранение порядка подзадач
    async function saveSubtasksOrder(groupId) {
        const container = document.getElementById(`subtasks-${groupId}`);
        if (!container) return;

        const subtaskOrder = Array.from(container.querySelectorAll('.subtask-item'))
            .map(subtask => subtask.dataset.subtaskId);

        try {
            await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/${groupId}/subtask/order`,
                {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ orderedSubtaskIds: subtaskOrder })
                }
            );
        } catch (error) {
            showNotification('Error', 'Failed to save subtasks order', 'error');
        }
    }

    // Управление модальными окнами для подзадач
    function openCreateSubtaskGroupModal() {
        document.getElementById('createSubtaskGroupModal').classList.remove('hidden');
    }

    function closeCreateSubtaskGroupModal() {
        document.getElementById('createSubtaskGroupModal').classList.add('hidden');
        document.getElementById('createSubtaskGroupForm').reset();
    }

    function openCreateSubtaskModal(groupId) {
        document.getElementById('subtaskGroupId').value = groupId;
        document.getElementById('createSubtaskModal').classList.remove('hidden');
    }

    function closeCreateSubtaskModal() {
        document.getElementById('createSubtaskModal').classList.add('hidden');
        document.getElementById('createSubtaskForm').reset();
    }

    // Обработчики форм
    async function handleCreateCategory(e) {
        e.preventDefault();
        const formData = new FormData(e.target);
        const request = {
            name: formData.get('name'),
            color: formData.get('colorText')
        };

        if (!/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(request.color)) {
            showNotification('Error', 'Invalid color format. Use HEX like #FF0000', 'error');
            return;
        }

        try {
            const response = await fetch(`/api/v1/projects/${projectId}/categories`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(request)
            });

            if (response.ok) {
                closeCreateCategoryModal();
                loadCategories();
                showNotification('Success', 'Category created', 'success');
            } else {
                const error = await response.json();
                showNotification('Error', error.message || 'Failed to create category', 'error');
            }
        } catch (error) {
            showNotification('Error', 'Network error', 'error');
        }
    }

    async function handleEditCategory(e) {
        e.preventDefault();
        const id = document.getElementById('editingCategoryId').value;
        const name = e.target.name.value;
        const color = e.target.colorText.value;

        try {
            const response = await fetch(`/api/v1/projects/${projectId}/categories/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, color })
            });

            if (response.ok) {
                showNotification('Success', 'Category updated', 'success');
                closeEditCategoryModal();
                await loadCategories();
            } else {
                const err = await response.json();
                showNotification('Error', err.message || 'Failed to update category', 'error');
            }
        } catch (error) {
            showNotification('Error', 'Network error', 'error');
        }
    }

    async function handleDeleteCategory(e) {
        e.preventDefault();
        const categoryId = document.getElementById('categoryToDeleteId').value;
        const newCategoryId = e.target.newCategoryId.value;

        try {
            const response = await fetch(`/api/v1/projects/${projectId}/categories/${categoryId}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ newCategoryId })
            });

            if (response.ok) {
                showNotification('Success', 'Category deleted', 'success');
                closeDeleteCategoryModal();
                await loadCategories();
            } else {
                const error = await response.json();
                showNotification('Error', error.message || 'Failed to delete category', 'error');
            }
        } catch (error) {
            showNotification('Error', 'Network error', 'error');
        }
    }

    async function handleCreateTask(e) {
        e.preventDefault();
        const categoryId = document.getElementById('taskCategoryId').value;
        const formData = new FormData(e.target);

        const deadlineValue = formData.get('deadline');
        const deadline = deadlineValue ? new Date(deadlineValue).toISOString() : null;

        const request = {
            name: formData.get('name'),
            description: formData.get('description'),
            deadline: deadline
        };

        try {
            // Оптимистичное обновление UI
            const newTask = {
                id: 'temp-' + Date.now(),
                ...request,
                status: Date.now() > Date.parse(deadline) ? 'EXPIRED' : 'NOT_COMPLETED',
                deadline: deadline
            };

            if (!tasksByCategory[categoryId]) {
                tasksByCategory[categoryId] = [];
            }

            tasksByCategory[categoryId].unshift(newTask);
            renderTasks(categoryId, [newTask], false);

            closeCreateTaskModal();
            showNotification('Success', 'Creating task...', 'success');

            // Отправляем на сервер
            const response = await fetch(`/api/v1/projects/${projectId}/categories/${categoryId}/tasks/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(request)
            });

            if (response.ok) {
                const data = await response;
                const createdTask = newTask;
                createdTask.id = data
                // Заменяем временную задачу на созданную
                const taskIndex = tasksByCategory[categoryId].findIndex(t => t.id === newTask.id);
                if (taskIndex >= 0) {
                    tasksByCategory[categoryId][taskIndex] = createdTask;
                }

                // Обновляем кэш
                const cachedData = loadFromCache('projectData') || {};
                cachedData.tasksByCategory = tasksByCategory;
                saveToCache('projectData', cachedData);

                // Перерисовываем задачи
                renderTasks(categoryId, tasksByCategory[categoryId], false);
                showNotification('Success', 'Task created successfully', 'success');
            } else {
                // Откатываем изменения в случае ошибки
                tasksByCategory[categoryId] = tasksByCategory[categoryId].filter(t => t.id !== newTask.id);
                renderTasks(categoryId, tasksByCategory[categoryId], false);

                const error = await response.json();
                showNotification('Error', error.message || 'Failed to create task', 'error');
            }
        } catch (error) {
            console.error('Failed to create task:', error);
            showNotification('Error', 'Network error', 'error');
        }
    }

    async function handleCreateSubtaskGroup(e) {
        e.preventDefault();
        const formData = new FormData(e.target);
        const request = {
            name: formData.get('name')
        };

        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/create`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(request)
                }
            );

            if (response.ok) {
                closeCreateSubtaskGroupModal();
                await loadSubtaskGroups(currentTask.id);
                showNotification('Success', 'Subtask group created', 'success');
            } else {
                const error = await response.json();
                showNotification('Error', error.message || 'Failed to create group', 'error');
            }
        } catch (error) {
            showNotification('Error', 'Network error', 'error');
        }
    }

    async function handleCreateSubtask(e) {
        e.preventDefault();
        const groupId = document.getElementById('subtaskGroupId').value;
        const formData = new FormData(e.target);
        const request = {
            name: formData.get('name')
        };

        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/${groupId}/subtask/create`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(request)
                }
            );

            if (response.ok) {
                closeCreateSubtaskModal();
                await loadSubtaskGroups(currentTask.id);
                showNotification('Success', 'Subtask created', 'success');
            } else {
                const error = await response.json();
                showNotification('Error', error.message || 'Failed to create subtask', 'error');
            }
        } catch (error) {
            showNotification('Error', 'Network error', 'error');
        }
    }

    async function handleDeleteTask() {
        if (!confirm('Are you sure you want to delete this task and all its subtasks?')) return;

        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}`,
                { method: 'DELETE' }
            );

            if (response.ok) {
                showNotification('Success', 'Task deleted', 'success');
                document.querySelector(`[data-task-id="${currentTask.id}"]`).remove();
                closeTaskModal();
            } else {
                const error = await response.json();
                showNotification('Error', error.message || 'Failed to delete task', 'error');
            }
        } catch (error) {
            showNotification('Error', 'Network error', 'error');
        }
    }

    // Управление подзадачами
    async function deleteSubtaskGroup(groupId) {
        if (!confirm('Are you sure you want to delete this group and all its subtasks?')) return;

        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/${groupId}`,
                { method: 'DELETE' }
            );

            if (response.ok) {
                await loadSubtaskGroups(currentTask.id);
                showNotification('Success', 'Group deleted', 'success');
            } else {
                const error = await response.json();
                showNotification('Error', error.message || 'Failed to delete group', 'error');
            }
        } catch (error) {
            showNotification('Error', 'Network error', 'error');
        }
    }

    async function deleteSubtask(groupId, subtaskId) {
        if (!confirm('Are you sure you want to delete this subtask?')) return;

        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/${groupId}/subtask/${subtaskId}`,
                { method: 'DELETE' }
            );

            if (response.ok) {
                await loadSubtaskGroups(currentTask.id);
                showNotification('Success', 'Subtask deleted', 'success');
            } else {
                const error = await response.json();
                showNotification('Error', error.message || 'Failed to delete subtask', 'error');
            }
        } catch (error) {
            showNotification('Error', 'Network error', 'error');
        }
    }

    async function toggleGroupStatus(groupId, completed) {
        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/${groupId}/status?completed=${completed}`,
                {method: 'PATCH'}
            );

            if (!response.ok) {
                showNotification('Ошибка при обновлении статуса группы');
                return;
            }

            const {newStatus} = await response.json();
            currentTask.status = newStatus; // обновляем локальную задачу

            // Обновляем локальные данные подзадач
            const group = subtaskGroups.find(g => g.id === groupId);
            if (group) {
                group.completed = completed;
                group.subtasks?.forEach(s => s.completed = completed);
            }

            renderSubtaskGroups();
            updateTaskStatusOnBoard(currentTask.id, newStatus); // 🆕 обновление на доске

        } catch (error) {
            showNotification('Ошибка при обновлении статуса группы подзадач');
            console.error(error);
        }
    }


    async function toggleSubtaskStatus(groupId, subtaskId, completed) {
        try {
            const response = await fetch(
                `/api/v1/projects/${projectId}/categories/${currentCategoryId}/tasks/${currentTask.id}/groups/${groupId}/subtask/${subtaskId}/status?completed=${completed}`,
                { method: 'PATCH' }
            );

            if (!response.ok) {
                const error = await response.json();
                showNotification('Error', error.message || 'Failed to update subtask', 'error');
                document.querySelector(`.subtask-item[data-subtask-id="${subtaskId}"] .subtask-checkbox`).checked = !completed;
                return;
            }

            const { newStatus } = await response.json();
            currentTask.status = newStatus;

            const group = subtaskGroups.find(g => g.id === groupId);
            if (group) {
                const subtask = group.subtasks?.find(s => s.id === subtaskId);
                if (subtask) {
                    subtask.completed = completed;
                }
                group.completed = group.subtasks.every(s => s.completed);
            }

            renderSubtaskGroups();
            updateTaskStatusOnBoard(currentTask.id, newStatus); // 🆕 обновление на доске

        } catch (error) {
            showNotification('Error', 'Network error', 'error');
            document.querySelector(`.subtask-item[data-subtask-id="${subtaskId}"] .subtask-checkbox`).checked = !completed;
        }
    }

    function updateTaskStatusOnBoard(taskId, newStatus) {
        const taskEl = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
        if (taskEl) {
            const statusEl = taskEl.querySelector('.task-status');
            if (statusEl) {
                statusEl.textContent = newStatus;
            }
        }
    }



    // Уведомления
    const notificationQueue = [];
    let isNotificationShowing = false;

    function showNotification(title, message, type) {
        notificationQueue.push({ title, message, type });
        processNotificationQueue();
    }

    function processNotificationQueue() {
        if (isNotificationShowing || notificationQueue.length === 0) return;

        isNotificationShowing = true;
        const { title, message, type } = notificationQueue.shift();

        const notification = document.getElementById('notification');
        const notificationTitle = document.getElementById('notification-title');
        const notificationMessage = document.getElementById('notification-message');
        const notificationIcon = document.getElementById('notification-icon');

        notificationTitle.textContent = title;
        notificationMessage.textContent = message;

        notification.className = 'notification';
        notification.classList.add(type);
        notificationIcon.textContent = type === 'success' ? '✓' : '✗';

        notification.classList.remove('hidden');
        notification.classList.add('show');

        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                notification.classList.add('hidden');
                isNotificationShowing = false;
                processNotificationQueue();
            }, 300);
        }, 1500);
    }

    function formatLocalDateTime(date) {
        const pad = num => String(num).padStart(2, '0');

        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1); // месяцы от 0 до 11
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());

        return `${year}-${month}-${day}T${hours}:${minutes}`;
    }
</script>
</body>
</html>